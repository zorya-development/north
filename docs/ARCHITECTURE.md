# Architecture Reference

Detailed reference for the North codebase. For essential conventions and workflows, see `CLAUDE.md`.

## Project Structure

```
north/
├── Cargo.toml                  # Workspace config (resolver 2)
├── rust-toolchain.toml         # Stable + wasm32-unknown-unknown
├── diesel.toml                 # Diesel CLI config (schema.rs path)
├── justfile                    # Dev commands
├── docker-compose.yml          # app, PostgreSQL 17, Redis 7
├── docker/
│   ├── base/Dockerfile         # Base image: Rust toolchain, cargo-leptos, diesel_cli, wasm target
│   ├── base/VERSION            # Semver for base image (source of truth)
│   ├── dev/Dockerfile          # Extends base, adds just + tailwindcss v4
│   └── prod/Dockerfile         # Multi-stage (base → debian:bookworm-slim)
├── cliff.toml                  # git-cliff changelog config
├── migrations/                 # Diesel reversible migrations (up.sql + down.sql)
├── style/main.css              # TailwindCSS v4, dark theme, Inter + JetBrains Mono
├── public/                     # Static assets served at /public
├── uploads/                    # User-uploaded files (volume mount)
├── docs/                       # PRD.md, DESIGN.md, UI_KIT.md
├── chart/                      # Helm chart for Kubernetes deployment
├── .github/workflows/
│   ├── test.yml                # CI: fmt, clippy, test
│   └── release.yml             # Release: prod Docker image + GitHub release on master
│
└── crates/
    ├── dto/                    # Pure data types (no IO) — compiled for both server and WASM
    ├── db/                     # Diesel schema, models, pool type
    ├── core/                   # Business logic layer (all services, filter DSL, Diesel queries)
    ├── server-fns/             # Leptos #[server] functions — RPC boundary
    ├── repositories/           # Thin async facade over server functions
    ├── stores/                 # Reactive client state
    ├── app/                    # Leptos library (SSR + WASM hydration)
    ├── ui/                     # Generic UI component library (no dto deps)
    └── server/                 # Axum binary
```

## Crate Details

### dto (north-dto)
Pure data types with serde + chrono, no IO. Compiled for both server and WASM. Includes recurrence types (`RecurrenceType`, `RecurrenceRule`, `Frequency`, `Weekday`) with RRULE serialization, human-readable `summarize()`, and after-completion/scheduled modes. Key types:
- `Task` (includes enrichment fields: project_title, tags, subtask_count, completed_subtask_count, actionable, recurrence_type, recurrence_rule)
- `CreateTask` (includes optional `sort_key` for positional insertion)
- `TaskFilter`, `ProjectFilter`, `ProjectStatus` (Active, Archived)
- `UserSettings` (review_interval_days, default_sequential_limit, timezone)
- `SavedFilter`, `DslSuggestion` (autocomplete suggestion DTO)
- Utility modules: `serde_helpers` (three-state Option serialization), `sort_key` (fractional indexing)

### db (north-db)
Diesel infrastructure: `schema.rs` (auto-generated by `diesel print-schema`), model structs (`XxxRow` for reading, `NewXxx` for inserting, `XxxChangeset` for updating), PG enum mappings via `diesel-derive-enum`, `DbPool` type alias for `diesel_async::deadpool::Pool<AsyncPgConnection>`.

### core (north-core)
Business logic layer. Contains all services: `TaskService`, `ProjectService`, `TagService`, `UserService`, `StatsService`, `FilterService`. Each service is a struct with static async methods using Diesel query builder directly.

Key patterns:
- `TaskService::enrich()` — batch metadata loading (projects, tags, subtask counts) to avoid N+1
- `compute_actionable()` — sequential task logic in Rust
- `execute_dsl_filter()` — filter DSL evaluation via `filter::eval_expr`

**Filter DSL subsystem** (`core/filter/`): AST types (`dsl.rs`), recursive descent parser (`parser.rs`), autocomplete context detection (`context.rs`), server-side suggestion generation (`autocomplete.rs`), AST evaluation (`translator.rs`), and `TaskFieldRegistry` (`field_registry.rs`) with compile-time exhaustive `Task` destructure for field safety. Supports fields (title, body, project, tags, status, due_date, start_at, created, updated), operators (`=`, `!=`, `=~`, `>`, `<`, `>=`, `<=`, `is null`, `in [...]`), logical operators (`AND`, `OR`, `NOT`, parentheses), and `ORDER BY`.

### stores (north-stores)
Reactive client state. `AppStore` wraps all sub-stores, provided globally via context:
- **TaskStore** — `RwSignal<Vec<Task>>`, optimistic updates. Inbox uses `AppStore`; other pages create local stores. Two creation methods: `create_task()` (fire-and-forget, updates parent's subtask_count) and `create_task_async()` (async, skips parent update — used by inline input).
- **ProjectStore** — reactive project state
- **TagStore** — cached reactive tag state, used by pickers
- **SavedFilterStore** — CRUD + reactive state for saved filters
- **FilterDslStore** — DSL query text, validation, suggestions, execution results
- **TaskDetailModalStore** — modal state, navigation, subtask handling
- **ModalStore** — string-based modal registry (`open()`, `close()`, `is_open()`, `is_any_open()`). Decouples keyboard listeners from modal DOM structure.
- **StatusBarStore** — bottom-bar messages. `show_message(text, variant)` (persistent with spinner), `notify(variant, text)` (auto-dismissing toast, 10s). Variants: Info, Danger, Success.
- **BrowserStorageStore** — reactive proxy over localStorage. Lazily creates `RwSignal<bool>` per key. Used for per-page UI toggles (e.g. `north:hide-non-actionable:{page}`).

### repositories (north-repositories)
Thin async facade. Decouples stores from server function details. No business logic — pure pass-through. Includes `TaskRepository`, `ProjectRepository`, `FilterRepository`, `TagRepository`, `SettingsRepository`.

Defines domain models used by the frontend (stores, controllers):
- **TaskModel** — wraps `Task` DTO with parsed `Recurrence` (not raw strings), enrichment fields (project_title, tags, subtask counts, actionable). Constructed via `From<Task>`.
- **Recurrence** — parsed recurrence rule (`RecurrenceType` + `RecurrenceRule`), provides `summarize()` and `rule_string()` convenience methods.

Other repositories return DTOs directly (`Project`, `Tag`, `SavedFilter`, `UserSettings`).

### server-fns (north-server-fns)
Leptos `#[server]` RPC boundary. Each function extracts `DbPool` from context and `user_id` from JWT, then delegates to core. The `#[server]` macro generates client stubs (HTTP POST) and server handlers. Covers tasks, projects, filters, tags, and settings.

### ui (north-ui)
Generic UI component library. No dto dependencies — only `leptos`, `pulldown-cmark`, `ammonia`. Components: `Icon`/`IconKind`, `DropdownMenu`/`DropdownItem`, `Popover`, `Modal`, `Checkbox`, `MarkdownView`, `AutocompleteDropdown`/`SuggestionItem`, `Spinner`.

### app (north-app)
Leptos library crate. Features: `hydrate` (WASM client), `ssr` (server-side).

**Pages** (`pages/`): login, inbox, today, all_tasks, project, archive, review, settings, filter, filter_help. Each follows container/controller/view pattern.

**Containers** (`containers/`): Complex stateful domain components — autocomplete, inline_task_input, project_picker, sidebar, tag_picker, task_checkbox, task_detail_modal, task_list_item, task_meta, traversable_task_list.

**Components** (`components/`): Simpler/presentational — date_picker, filter_autocomplete, recurrence_modal, keybindings_modal, status_bar, drag_drop, theme_toggle, layout.

**Atoms** (`atoms/`): UI Kit atoms — currently `Text` (TextVariant, TextColor, TextTag) based on MD3 type scale. Enum props use `fn classes(self) -> &'static str` pattern.

### server (north-server)
Axum binary. Auth middleware injects `AuthUser { id, role }` into request extensions. Route handlers delegate to `north-core`.

## REST API Routes

```
POST   /api/auth/login        (public)
POST   /api/auth/logout       (public)
GET    /api/tasks              (protected, supports TaskFilter query params)
POST   /api/tasks              (protected)
GET    /api/tasks/:id          (protected)
PATCH  /api/tasks/:id          (protected)
DELETE /api/tasks/:id          (protected)
PATCH  /api/tasks/:id/review   (protected)
GET    /api/projects           (protected, supports ProjectFilter query params)
POST   /api/projects           (protected)
GET    /api/projects/:id       (protected)
PATCH  /api/projects/:id       (protected)
GET    /api/stats              (protected)
```

## Data Models

```
users (email, password_hash, name, role ENUM, settings JSONB, created_at, updated_at)
├── projects (title, description, color, view_type ENUM, status ENUM, position, created_at, updated_at)
│   └── tasks (title, body, sort_key, sequential_limit, start_at, due_date, completed_at, reviewed_at, recurrence_type ENUM, recurrence_rule, ...)
│       ├── tasks (subtasks via parent_id self-reference)
│       └── task_tags → tags (join table)
├── tags (name, color, UNIQUE per user)
├── saved_filters (title, query, position, created_at, updated_at)
└── images (path, filename, content_type, size_bytes)
```

DB enums: `user_role` (admin, user), `project_view_type` (list, kanban), `project_status` (active, archived), `recurrence_type` (scheduled, after_completion).
Triggers: `update_updated_at()` on users, projects, tasks.

## Component Details

### TraversableTaskList
Keyboard-driven tree list container — the sole list component for all pages. Builds a flat `Vec<FlatNode>` from hierarchical tasks via DFS pre-order (active sorted by sort_key first, completed at bottom per parent group). Maintains a task-ID-based cursor with tree-aware navigation (Up/Down = siblings, Left = parent, Right = first child).

Features:
- Inline editing (Enter to edit, Enter to save, Escape to cancel)
- Inline creation (Ctrl+Enter after, Shift+Enter before, Tab/Shift+Tab for indent/outdent)
- `TtlHandle` via optional `handle` prop for external control (e.g. `start_create_top()`)
- Keyboard reordering (Shift+Arrow) and drag-and-drop (Above/Below/Nest zones with cycle prevention)
- Two keyboard modes: **global** (window_event_listener, skips when ModalStore reports any modal open) and **scoped** (element-level, used inside modals)
- R key marks selected task as reviewed (when `item_config.show_review` is true)

### ExtraVisibleIds
Context type (`ExtraVisibleIds(RwSignal<Vec<i64>>)`) provided by TraversableTaskList and TaskDetailModal. Keeps inline-created subtasks visible even when they exceed the sequential_limit. Scoped to container lifecycle.

### ItemConfig
Config struct bundling display/behavior props for TaskListItem: `show_review`, `show_project`, `draggable`. Defaults: `show_review: false`, `show_project: true`, `draggable: false`.

### TaskListItem
Reusable task row. Renders checkbox, title, action bar (date/project/tag pickers, kebab menu), and metadata. Takes `task_id: i64` and `config: ItemConfig`.

### InlineTaskInput
Borderless input for rapid subtask creation inside TaskDetailModal. Enter creates subtask (inheriting parent's project_id), clears input, keeps it open. Escape/blur hides. Created IDs pushed to ExtraVisibleIds.

### TaskCheckbox
Container/controller/view. Manages checked state and completion toggle via AppStore. Displays progress for parent tasks with subtasks.

### TaskMeta
Container/view with `TaskMetaItem` sub-component. Computes display variants (e.g. Danger for past-due dates), parses recurrence rules into summaries. `TaskMetaItem` is a reusable icon+text badge with variant-based color.

### Recurrence
Tasks support recurring schedules via `recurrence_type` (Scheduled/AfterCompletion) and `recurrence_rule` (RRULE string). `RecurrenceModal` provides the UI — `ReactiveRecurrenceRule` wraps the pure `RecurrenceRule` with Leptos signals.

### Actionable Visibility Toggle
Each page controller manages `hide_non_actionable: Signal<bool>` backed by BrowserStorageStore with per-page keys. Passed as `Option<Signal<bool>>` to TraversableTaskList for tree filtering.

## Auth

JWT (7-day expiry) in httpOnly cookie. REST API also accepts `Authorization: Bearer` header. Server functions extract auth via `leptos_axum::extract()`. Password hashing with Argon2.

## Token Parsing

`parse_tokens()` in core crate extracts `#tags` and `@project` references from task title/body text. Core resolves these to DB records.

## Docker Images

Three Dockerfiles, layered:

| Image | Path | Purpose |
|---|---|---|
| **base** | `docker/base/Dockerfile` | Rust toolchain, cargo-leptos, diesel_cli, wasm32 target |
| **dev** | `docker/dev/Dockerfile` | Extends base, adds `just` and `tailwindcss` CLI |
| **prod** | `docker/prod/Dockerfile` | Runtime-only: `debian:bookworm-slim` with pre-built binary |

- `docker/base/VERSION` is the single source of truth for base image version
- `docker-compose.yml` builds base locally as `north-base:<version>`
- CI pulls base from `ghcr.io/zorya-development/north/base:<version>`

## CI/CD

**test.yml** (push to master + all PRs):
1. `resolve` — reads `docker/base/VERSION`, detects changes in `docker/base/**`
2. `build-base` — conditional: builds and pushes base image only if base files changed
3. `check` — runs `cargo fmt --check`, `cargo clippy -- -D warnings`, `cargo test`

**release.yml** (push to master only):
1. `resolve` — reads app version from `Cargo.toml`, checks if git tag exists
2. `build` — builds release binary in base container, uploads artifacts
3. `package` — packages into slim image, pushes to ghcr.io, generates changelog via git-cliff, creates GitHub release

## Release Process

To release a new version:
1. `just bump-version {major,minor,patch}`
2. Commit and push to master
3. Release workflow automatically builds, packages, and creates GitHub release

To bump the base Docker image:
1. Modify `docker/base/Dockerfile`
2. `just bump-base {major,minor,patch}`
3. Commit and push — test workflow builds and pushes the new base image
